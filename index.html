<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Miya — AI Safety & Eval</title>
<style>
  /* --- Reset & Layout (保持不變) --- */
  html, body {
    margin: 0; padding: 0;
    height: 100%;
    font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
    background: #000;
    color: #e0e0e0;
    overflow-x: hidden;
    overflow-y: auto; 
  }

  /* --- Nebula Canvas (保持不變) --- */
  canvas#nebula {
    position: fixed;
    inset: 0;
    display: block;
    z-index: 0;
    pointer-events: none;
  }

  /* --- Main Container (保持不變) --- */
  .container {
    position: relative;
    z-index: 1;
    max-width: 680px;
    margin: 0 auto;
    padding: 80px 24px 120px;
  }

  /* --- Header & Project List (略 — 保持不變) --- */
  header { margin-bottom: 60px; }
  h1 { /* ... 樣式不變 ... */ }
  p.tagline { /* ... 樣式不變 ... */ }
  .section-title { /* ... 樣式不變 ... */ }
  .project-list { display: flex; flex-direction: column; gap: 24px; }
  .meta-tags { /* ... 樣式不變 ... */ }
  .meta-item { /* ... 樣式不變 ... */ }
  .meta-item::before { /* ... 樣式不變 ... */ }
  footer { /* ... 樣式不變 ... */ }

  /* ============================================== */
  /* ★★★ 核心修改：流動四邊框 CSS ★★★ */
  /* ============================================== */

  /* 卡片外層框：負責流光效果的定位和觸發 */
  .case-frame {
    /* 必須是區塊連結，所以我們將 a.case-card 替換為 .case-frame */
    display: block; 
    text-decoration: none; /* 移除連結下劃線 */
    position: relative;
    border-radius: 14px;
    padding: 2px; /* 留出空間給 4 條線段 */
    
    /* 讓卡片上浮的動畫效果從外層開始 */
    transition: transform 0.15s ease; 
  }

  /* 懸停時上浮 */
  .case-frame:hover {
    transform: translateY(-4px); 
  }


  /* 卡片本體：包含內容和黑玻璃效果 */
  .case-card-body {
    position: relative;
    z-index: 2; /* 確保內容在流光線段之上 */
    border-radius: 12px;
    
    background: rgba(0, 0, 0, 0.5); /* 黑玻璃底色 */
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);

    padding: 24px;
    color: #fff;
    /* 增加懸停時，背景變深的過渡效果 */
    transition: background 0.15s ease;
  }
  
  /* 懸停時本體變深 */
  .case-frame:hover .case-card-body {
    background: rgba(0, 0, 0, 0.8);
  }

  /* 卡片內文樣式 */
  .case-card-body h2 {
    margin: 0 0 8px;
    font-size: 18px;
    font-weight: 600;
  }

  .case-card-body p {
    margin: 0 0 16px;
    font-size: 14px;
    line-height: 1.5;
    color: rgba(255, 255, 255, 0.7);
  }
  
  /* ---------------------- */
  /* 4 條跑動線段 (流光) */
  /* ---------------------- */

  /* 上、下線段，及 左、右 ::before/::after 的基礎樣式 */
  .case-frame .line-top,
  .case-frame .line-bottom,
  .case-frame::before,
  .case-frame::after {
    content: "";
    position: absolute;
    z-index: 1;
    background: linear-gradient(
      90deg,
      #3a00ff,
      #7b2cff,
      #00d4ff,
      #3a00ff
    );
    background-size: 300% 300%;
    opacity: 0; /* 預設隱藏 */
    transition: opacity .25s; /* 懸停時淡入 */
    pointer-events: none; /* 確保不擋住點擊 */
  }

  /* 上、下（水平線段）定位 */
  .case-frame .line-top,
  .case-frame .line-bottom {
    height: 2px;
    left: 0;
    right: 0;
  }

  .case-frame .line-top {
    top: 0;
    animation: cyber-h 2s linear infinite paused; /* 預設暫停 */
  }

  .case-frame .line-bottom {
    bottom: 0;
    animation: cyber-h 2s linear infinite paused reverse; /* 反向流動 */
  }

  /* 左、右（垂直線段）定位 */
  /* 這裡重新定義了背景漸變的方向，讓垂直線段跑得好看 */
  .case-frame::before,
  .case-frame::after {
    width: 2px;
    top: 0;
    bottom: 0;
    background: linear-gradient(
      180deg, /* 垂直流動 */
      #3a00ff,
      #7b2cff,
      #00d4ff,
      #3a00ff
    );
  }

  .case-frame::before {
    left: 0;
    animation: cyber-v 2s linear infinite paused;
  }

  .case-frame::after {
    right: 0;
    animation: cyber-v 2s linear infinite paused reverse;
  }

  /* hover 時啟動所有線段 */
  .case-frame:hover .line-top,
  .case-frame:hover .line-bottom,
  .case-frame:hover::before,
  .case-frame:hover::after {
    opacity: 1;
    animation-play-state: running;
  }

  /* 水平線動畫 */
  @keyframes cyber-h {
    0% { background-position: 0% 50%; }
    100% { background-position: 300% 50%; }
  }

  /* 垂直線動畫 */
  @keyframes cyber-v {
    0% { background-position: 50% 0%; }
    100% { background-position: 50% 300%; }
  }

  @media (max-width: 600px) {
    .container { padding: 40px 20px; }
    h1 { font-size: 28px; }
  }
</style>
</head>
<body>

<canvas id="nebula"></canvas>

<div class="container">
  
  <header>
    <h1>Miya</h1>
    <p class="tagline">"Nebula in a jewelry box" as a metaphor for constrained intelligence.</p>
  </header>

  <main>
    <div class="section-title">Research & Case Studies</div>
    
    <div class="project-list">
      
      <a href="#" class="case-frame">
        <span class="line-top"></span>
        <span class="line-bottom"></span>
        <div class="case-card-body">
          <h2>Adversarial Robustness Evaluation</h2>
          <p>Designed a multi-turn red teaming framework to detect "Jailbreak" vulnerabilities in large language models before deployment.</p>
          <div class="meta-tags">
            <span class="meta-item">Red Teaming</span>
            <span class="meta-item">Safety Benchmarks</span>
          </div>
        </div>
      </a>

      <a href="#" class="case-frame">
        <span class="line-top"></span>
        <span class="line-bottom"></span>
        <div class="case-card-body">
          <h2>Automated Hallucination Detection</h2>
          <p>Built an eval pipeline using reference-free metrics to quantify factual inconsistencies in RAG-based systems.</p>
          <div class="meta-tags">
            <span class="meta-item">Model Eval</span>
            <span class="meta-item">Factuality</span>
          </div>
        </div>
      </a>

      <a href="#" class="case-frame">
        <span class="line-top"></span>
        <span class="line-bottom"></span>
        <div class="case-card-body">
          <h2>Constitutional AI Alignment</h2>
          <p>Experimented with RLAIF (Reinforcement Learning from AI Feedback) to align models with specific safety principles without heavy human labeling.</p>
          <div class="meta-tags">
            <span class="meta-item">Alignment Research</span>
            <span class="meta-item">RLAIF</span>
          </div>
        </div>
      </a>

    </div>
  </main>

  <footer>
    <small>© 2025 Miya • AI Safety Research</small>
  </footer>
</div>

<script>
/* JS 部分保持不變 (Nebula Particles) */
const canvas = document.getElementById('nebula');
const ctx = canvas.getContext('2d');
let W=0,H=0, DPR = Math.max(1, window.devicePixelRatio || 1);

function resize(){
  W = innerWidth;
  H = innerHeight;
  canvas.width = Math.floor(W * DPR);
  canvas.height = Math.floor(H * DPR);
  canvas.style.width = W + 'px';
  canvas.style.height = H + 'px';
  ctx.setTransform(DPR,0,0,DPR,0,0);
}
addEventListener('resize', resize);
resize();

/* Config */
const LAYERS = 3;
const PARTICLE_COUNT = 45; 

/* PALETTE - 冷色調 */
const PALETTE = [
  {h: 250, s: 80, l: 60}, // Deep Purple
  {h: 210, s: 80, l: 60}, // Electric Blue
  {h: 190, s: 75, l: 55}, // Cyan/Teal
  {h: 270, s: 65, l: 50}  // Violet
];

function rand(min, max){ return Math.random()*(max-min)+min; }

class Particle {
  constructor(layerIndex){
    this.layer = layerIndex;
    this.reset(true);
  }
  reset(initial=false){
    this.x = rand(-0.3*W, 1.3*W);
    this.y = rand(-0.3*H, 1.3*H);
    const base = 0.1 + this.layer * 0.6; 
    this.vx = rand(-0.03,0.03) * base;
    this.vy = rand(-0.01,0.01) * base;
    this.size = rand(120, 420) * (1 + this.layer*0.6);
    
    const color = PALETTE[(this.layer + Math.floor(Math.random()*PALETTE.length)) % PALETTE.length];
    
    // Hue variation
    this.h = color.h + rand(-15,15); 
    this.s = color.s + rand(-6,6);
    this.l = color.l + rand(-6,6);
    
    this.alpha = rand(0.035, 0.18);
    this.twist = rand(0,Math.PI*2);
    if(initial) this.age = rand(0,200);
    else this.age = 0;
  }
  step(dt){
    const t = performance.now() * 0.00008;
    const flowX = Math.cos((this.y*0.002 + t + this.twist))*0.15;
    const flowY = Math.sin((this.x*0.002 + t - this.twist))*0.15;
    this.x += (this.vx + flowX) * dt;
    this.y += (this.vy + flowY) * dt;
    this.age += dt;
    if(this.x < -0.5*W || this.x > 1.5*W || this.y < -0.5*H || this.y > 1.5*H) this.reset();
  }
  draw(ctx){
    const r = this.size * (0.7 + 0.3*Math.sin(this.age*0.002 + this.twist));
    const g = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, r);
    g.addColorStop(0, `hsla(${this.h}, ${this.s}%, ${this.l}%, ${this.alpha})`);
    g.addColorStop(0.25, `hsla(${this.h+10}, ${this.s}%, ${this.l-6}%, ${this.alpha*0.85})`);
    g.addColorStop(0.6, `hsla(${this.h+30}, ${this.s-10}%, ${this.l-12}%, ${this.alpha*0.45})`);
    g.addColorStop(1, `hsla(${this.h+40}, ${this.s-20}%, ${this.l-20}%, 0)`);
    ctx.fillStyle = g;
    ctx.beginPath();
    ctx.arc(this.x, this.y, r, 0, Math.PI*2);
    ctx.fill();
  }
}

const layers = [];
for(let L=0; L<LAYERS; L++){
  const arr = [];
  for(let i=0;i<PARTICLE_COUNT;i++) arr.push(new Particle(L));
  layers.push(arr);
}

let last = performance.now();
function frame(now){
  const dt = Math.min(60, now - last); 
  last = now;
  
  // Clear with slight fade (Original Logic)
  ctx.globalCompositeOperation = 'source-over';
  ctx.fillStyle = 'rgba(0,0,0,0.12)';
  ctx.fillRect(0,0,W,H);

  // Additive Blending (Original Logic - The "Glow" Key)
  ctx.globalCompositeOperation = 'lighter';
  for(let L=0; L<LAYERS; L++){
    const depthAlpha = 0.6 + L*0.6; 
    for(const p of layers[L]){
      p.step(dt);
      ctx.save();
      ctx.globalAlpha = Math.min(1, p.alpha * depthAlpha);
      p.draw(ctx);
      ctx.restore();
    }
  }

  // Vignette (Original Logic)
  ctx.globalCompositeOperation = 'source-over';
  const vg = ctx.createRadialGradient(W/2, H/2, Math.min(W,H)*0.2, W/2, H/2, Math.max(W,H)*0.8);
  vg.addColorStop(0, 'rgba(0,0,0,0)');
  vg.addColorStop(1, 'rgba(0,0,0,0.18)');
  ctx.fillStyle = vg;
  ctx.fillRect(0,0,W,H);

  requestAnimationFrame(frame);
}
requestAnimationFrame(frame);

/* Interactive handlers */
window.addEventListener('pointermove', (e)=>{
  const mx = e.clientX, my = e.clientY;
  for(let L=0; L<LAYERS; L++){
    const arr = layers[L];
    for(let i=0;i<6;i++){
      const p = arr[Math.floor(Math.random()*arr.length)];
      const dx = p.x - mx, dy = p.y - my;
      const d2 = dx*dx + dy*dy;
      if(d2 < 120000){
        p.vx += (dx*0.00002) * (1+L*0.5);
        p.vy += (dy*0.00002) * (1+L*0.5);
      }
    }
  }
});
window.addEventListener('click', ()=>{ 
  for(const arr of layers) for(const p of arr) { p.vx += rand(-0.06,0.06); p.vy += rand(-0.03,0.03); }
});
</script>
</body>
</html>
